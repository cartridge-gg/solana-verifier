use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=src");

    // Find the workspace root directory
    let current_dir = env::current_dir().unwrap();
    let workspace_root = find_workspace_root(&current_dir).unwrap_or(current_dir);

    // Find all Rust files in the current crate's src directory
    let src_dir = Path::new("src");
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("executable_dispatch.rs");

    let mut types = HashSet::new();

    // Find all files implementing the Executable trait in the current crate
    visit_dir(src_dir, &mut types, "crate");

    // Discover and scan all other crates in the workspace for Executable trait implementations
    discover_and_scan_crates(&workspace_root, &mut types);

    // Generate the dispatch code
    let mut dispatch_code = String::new();

    // Add header with imports
    dispatch_code.push_str("// AUTO-GENERATED by build.rs\n");
    dispatch_code.push_str("// Do not edit this file directly\n\n");

    // Generate the execute function
    dispatch_code
        .push_str("pub fn execute(stack: &mut verifier::state::BidirectionalStackAccount) {\n");
    dispatch_code.push_str("    let data = stack.borrow_mut_front();\n");
    dispatch_code.push_str("    match data[0] {\n");

    // Add a case for each type
    for (type_name, crate_name) in &types {
        let struct_name = type_name.split("::").last().unwrap_or(type_name);

        if crate_name == "crate" {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!("        crate::{}::TYPE_TAG => {{\n", type_name));
            dispatch_code.push_str(&format!(
                "            let {} = crate::{}::cast_mut(&mut data[1..]);\n",
                struct_name.to_lowercase(),
                type_name
            ));
        } else {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!(
                "        {}::{}::TYPE_TAG => {{\n",
                crate_name, type_name
            ));
            dispatch_code.push_str(&format!(
                "            let {} = {}::{}::cast_mut(&mut data[1..]);\n",
                struct_name.to_lowercase(),
                crate_name,
                type_name
            ));
        }

        dispatch_code.push_str(&format!(
            "            {}.execute();\n",
            struct_name.to_lowercase()
        ));
        dispatch_code.push_str("        },\n");
    }

    // Add default case
    dispatch_code.push_str("        _ => {\n");
    dispatch_code.push_str("            panic!(\"Unknown type tag: {}\", data[0]);\n");
    dispatch_code.push_str("        }\n");
    dispatch_code.push_str("    }\n");
    dispatch_code.push_str("    stack.pop_front();\n");
    dispatch_code.push_str("}\n");

    // Write the generated code to a file
    let mut file = fs::File::create(out_path).unwrap();
    file.write_all(dispatch_code.as_bytes()).unwrap();

    println!(
        "cargo:warning=Auto-generated code for {} Executable types",
        types.len()
    );
}

// Helper function to find the workspace root directory
fn find_workspace_root(start_dir: &Path) -> Option<std::path::PathBuf> {
    let mut current = start_dir.to_path_buf();

    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists() {
            // Check if this is a workspace root by looking for [workspace] section
            if let Ok(content) = fs::read_to_string(&cargo_toml) {
                if content.contains("[workspace]") {
                    return Some(current);
                }
            }
        }

        if !current.pop() {
            break;
        }
    }

    None
}

// Function to discover and scan all crates in the workspace
fn discover_and_scan_crates(workspace_root: &Path, types: &mut HashSet<(String, String)>) {
    // Read the workspace Cargo.toml to find members
    let workspace_cargo = workspace_root.join("Cargo.toml");
    if let Ok(content) = fs::read_to_string(workspace_cargo) {
        // Parse the members array from [workspace] section
        if let Some(members_line) = content
            .lines()
            .find(|line| line.trim().starts_with("members"))
        {
            let members_str = members_line
                .split('=')
                .nth(1)
                .unwrap_or("")
                .trim()
                .trim_matches(|c| c == '[' || c == ']' || c == '"' || c == '\'');
            let members: Vec<&str> = members_str
                .split(',')
                .map(|s| s.trim().trim_matches(|c| c == '"' || c == '\''))
                .collect();

            for member in members {
                // Handle glob patterns like "programs/*"
                if member.contains('*') {
                    let glob_base = member.split('*').next().unwrap_or("");
                    let base_path = workspace_root.join(glob_base);

                    if base_path.exists() && base_path.is_dir() {
                        if let Ok(entries) = fs::read_dir(&base_path) {
                            for entry in entries.flatten() {
                                let path = entry.path();
                                if path.is_dir() && path.join("Cargo.toml").exists() {
                                    scan_crate(workspace_root, &path, types);
                                }
                            }
                        }
                    }
                } else {
                    // Direct member reference
                    let crate_path = workspace_root.join(member);
                    if crate_path.exists()
                        && crate_path.is_dir()
                        && crate_path.join("Cargo.toml").exists()
                    {
                        scan_crate(workspace_root, &crate_path, types);
                    }
                }
            }
        }
    }
}

// Function to scan a specific crate for Executable types
fn scan_crate(_workspace_root: &Path, crate_path: &Path, types: &mut HashSet<(String, String)>) {
    // Skip scanning the current crate as it's already handled
    if crate_path == env::current_dir().unwrap() {
        return;
    }

    // Get the crate name from the directory name or Cargo.toml
    let crate_name = if let Some(name) = crate_path.file_name() {
        name.to_string_lossy().to_string()
    } else {
        return;
    };

    // Check if this crate has a src directory
    let src_dir = crate_path.join("src");
    if src_dir.exists() && src_dir.is_dir() {
        // Add a rerun-if-changed directive for this crate
        let rel_path = pathdiff::diff_paths(&src_dir, &env::current_dir().unwrap())
            .unwrap_or_else(|| src_dir.clone());
        println!("cargo:rerun-if-changed={}", rel_path.display());

        // Visit the src directory to find Executable implementations
        visit_dir(&src_dir, types, &crate_name);
    }
}

// Helper function to recursively visit directories and find Rust files
fn visit_dir(dir: &Path, types: &mut HashSet<(String, String)>, crate_name: &str) {
    if dir.is_dir() {
        for entry in fs::read_dir(dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                visit_dir(&path, types, crate_name);
            } else if let Some(extension) = path.extension() {
                if extension == "rs" {
                    find_executable_types(&path, types, crate_name);
                }
            }
        }
    }
}

// Parse a Rust file to find types implementing the Executable trait
fn find_executable_types(
    file_path: &Path,
    types: &mut HashSet<(String, String)>,
    crate_name: &str,
) {
    let content = fs::read_to_string(file_path).unwrap();
    let file_name = file_path.file_name().unwrap().to_string_lossy();

    // Skip the traits.rs file since it defines the trait, but do check lib.rs for implementations
    if file_name == "traits.rs" {
        return;
    }

    // Look for module name - use empty string for lib.rs to create root-level paths
    let mod_name = if file_name == "lib.rs" {
        "".to_string()
    } else {
        file_path.file_stem().unwrap().to_string_lossy().to_string()
    };

    // Check if the file implements Executable trait
    if content.contains("impl Executable for")
        || content.contains("impl traits::Executable for")
        || content.contains("impl crate::traits::Executable for")
        || content.contains("impl dynamic::traits::Executable for")
        || content.contains("impl utils::Executable for")
    {
        // Extract struct names
        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("pub struct ") {
                let struct_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or_default()
                    .trim_matches(|c| c == '{' || c == ' ' || c == '\t');

                // Create the fully qualified path
                let full_path = if mod_name.is_empty() {
                    struct_name.to_string()
                } else {
                    format!("{}::{}", mod_name, struct_name)
                };

                // Add the fully qualified name and crate
                types.insert((full_path, crate_name.to_string()));
            }
        }
    }
}
