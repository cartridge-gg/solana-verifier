use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=src");

    // Get the current crate name from Cargo.toml
    let current_crate_name = env::var("CARGO_PKG_NAME").unwrap_or_else(|_| "unknown".to_string());
    
    // Find all Rust files in the current crate's src directory
    let src_dir = Path::new("src");
    let out_dir = env::var_os("OUT_DIR").unwrap();
    
    // Generate a unique filename based on the crate name
    let out_filename = format!("{}_executable_dispatch.rs", current_crate_name);
    let out_path = Path::new(&out_dir).join(out_filename);

    let mut types = HashSet::new();

    // Find all files implementing the Executable trait in the current crate
    visit_dir(src_dir, &mut types, "crate");
    
    // Generate the dispatch code
    let mut dispatch_code = String::new();

    // Add header with imports
    dispatch_code.push_str("// AUTO-GENERATED by build.rs\n");
    dispatch_code.push_str("// Do not edit this file directly\n\n");

    // Generate the execute function
    dispatch_code
        .push_str("pub fn execute(stack: &mut verifier::state::BidirectionalStackAccount) {\n");
    dispatch_code.push_str("    let data = stack.borrow_mut_front();\n");

    // We need to ensure we have enough data (at least 4 bytes for u32)
    dispatch_code.push_str("    if data.len() < 4 {\n");
    dispatch_code.push_str("        panic!(\"Data too short to contain type tag\");\n");
    dispatch_code.push_str("    }\n");

    // Read the 32-bit type tag from the first 4 bytes
    dispatch_code
        .push_str("    let type_tag_bytes: [u8; 4] = [data[0], data[1], data[2], data[3]];\n");
    dispatch_code.push_str("    let type_tag = u32::from_le_bytes(type_tag_bytes);\n");

    dispatch_code.push_str("    match type_tag {\n");

    // Add a case for each type in the current crate
    for (type_name, crate_name) in &types {
        let struct_name = type_name.split("::").last().unwrap_or(type_name);

        if crate_name == "crate" {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!("        crate::{}::TYPE_TAG => {{\n", type_name));
            dispatch_code.push_str(&format!(
                "            let {} = crate::{}::cast_mut(&mut data[4..]);\n",
                struct_name.to_lowercase(),
                type_name
            ));
            dispatch_code.push_str(&format!(
                "            {}.execute();\n",
                struct_name.to_lowercase()
            ));
            dispatch_code.push_str("        },\n");
        }
    }

    // Track already added types to avoid duplicates
    let mut added_types = HashSet::new();
    for (type_name, _) in &types {
        let struct_name = type_name.split("::").last().unwrap_or(type_name);
        added_types.insert(struct_name.to_string());
    }

    // Check main.rs for external type imports and add them to the match statement
    if let Ok(main_rs) = fs::read_to_string("src/main.rs") {
        for line in main_rs.lines() {
            let line = line.trim();
            if line.starts_with("use ") && line.contains("::") && !line.starts_with("use crate::") {
                let parts: Vec<&str> = line.trim_end_matches(';').split("::").collect();
                if parts.len() >= 2 {
                    let crate_name = parts[0].trim_start_matches("use ");
                    let type_name = parts.last().unwrap();
                    
                    // Skip if we've already added this type
                    if added_types.contains(&type_name.to_string()) {
                        continue;
                    }
                    
                    if main_rs.contains(&format!("{type_name}::TYPE_TAG")) {
                        let full_path = parts[1..].join("::");
                        let path_without_type = parts[1..parts.len()-1].join("::");
                        
                        dispatch_code.push_str(&format!("        // TYPE_TAG from external {} crate\n", crate_name));
                        if path_without_type.is_empty() {
                            dispatch_code.push_str(&format!("        {}::{}::TYPE_TAG => {{\n", crate_name, type_name));
                            dispatch_code.push_str(&format!(
                                "            let {} = {}::{}::cast_mut(&mut data[4..]);\n",
                                type_name.to_lowercase(),
                                crate_name,
                                type_name
                            ));
                        } else {
                            dispatch_code.push_str(&format!("        {}::{}::TYPE_TAG => {{\n", crate_name, full_path));
                            dispatch_code.push_str(&format!(
                                "            let {} = {}::{}::cast_mut(&mut data[4..]);\n",
                                type_name.to_lowercase(),
                                crate_name,
                                full_path
                            ));
                        }
                        dispatch_code.push_str(&format!(
                            "            {}.execute();\n",
                            type_name.to_lowercase()
                        ));
                        dispatch_code.push_str("        },\n");
                        
                        // Mark this type as added
                        added_types.insert(type_name.to_string());
                    }
                }
            }
        }
    }

    // Add default case
    dispatch_code.push_str("        _ => {\n");
    dispatch_code.push_str("            panic!(\"Unknown type tag: {}\", type_tag);\n");
    dispatch_code.push_str("        }\n");
    dispatch_code.push_str("    }\n");
    dispatch_code.push_str("}\n");

    // Write the generated code to a file
    let mut file = fs::File::create(out_path).unwrap();
    file.write_all(dispatch_code.as_bytes()).unwrap();

    println!(
        "cargo:warning=Auto-generated code for {} Executable types in {} crate",
        types.len(),
        current_crate_name
    );
}

// Helper function to recursively visit directories and find Rust files
fn visit_dir(dir: &Path, types: &mut HashSet<(String, String)>, crate_name: &str) {
    if dir.is_dir() {
        for entry in fs::read_dir(dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                visit_dir(&path, types, crate_name);
            } else if let Some(extension) = path.extension() {
                if extension == "rs" {
                    find_executable_types(&path, types, crate_name);
                }
            }
        }
    }
}

// Parse a Rust file to find types implementing the Executable trait
fn find_executable_types(
    file_path: &Path,
    types: &mut HashSet<(String, String)>,
    crate_name: &str,
) {
    let content = fs::read_to_string(file_path).unwrap();
    let file_name = file_path.file_name().unwrap().to_string_lossy();

    // Skip the traits.rs file since it defines the trait, but do check lib.rs for implementations
    if file_name == "traits.rs" {
        return;
    }

    // Look for module name - use empty string for lib.rs to create root-level paths
    let mod_name = if file_name == "lib.rs" {
        "".to_string()
    } else {
        file_path.file_stem().unwrap().to_string_lossy().to_string()
    };

    // Check if the file implements Executable trait
    if content.contains("impl Executable for")
        || content.contains("impl traits::Executable for")
        || content.contains("impl crate::traits::Executable for")
        || content.contains("impl dynamic::traits::Executable for")
        || content.contains("impl utils::Executable for")
    {
        // Extract struct names
        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("pub struct ") {
                let struct_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or_default()
                    .trim_matches(|c| c == '{' || c == ' ' || c == '\t');

                // Create the fully qualified path
                let full_path = if mod_name.is_empty() {
                    struct_name.to_string()
                } else {
                    format!("{}::{}", mod_name, struct_name)
                };

                // Add the fully qualified name and crate
                types.insert((full_path, crate_name.to_string()));
            }
        }
    }
}
