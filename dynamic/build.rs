use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=src");

    // Find all Rust files in the src directory
    let src_dir = Path::new("src");
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("executable_dispatch.rs");

    let mut types = HashSet::new();

    // Find all files implementing the Executable trait
    visit_dir(src_dir, &mut types);

    // Generate the dispatch code
    let mut dispatch_code = String::new();

    // Add header with imports
    dispatch_code.push_str("// AUTO-GENERATED by build.rs\n");
    dispatch_code.push_str("// Do not edit this file directly\n\n");

    // Import the Executable trait
    dispatch_code.push_str("use crate::traits::Executable;\n\n");

    // Generate the execute function
    dispatch_code
        .push_str("pub fn execute(stack: &mut verifier::state::BidirectionalStackAccount) {\n");
    dispatch_code.push_str("    let data = stack.borrow_mut_front();\n");
    dispatch_code.push_str("    match data[0] {\n");

    // Add a case for each type
    for type_name in &types {
        let struct_name = type_name.split("::").last().unwrap_or(type_name);

        dispatch_code.push_str(&format!("        crate::{}::TYPE_TAG => {{\n", type_name));
        dispatch_code.push_str(&format!(
            "            let {} = crate::{}::cast_mut(&mut data[1..]);\n",
            struct_name.to_lowercase(),
            type_name
        ));
        dispatch_code.push_str(&format!(
            "            {}.execute();\n",
            struct_name.to_lowercase()
        ));
        dispatch_code.push_str("        },\n");
    }

    // Add default case
    dispatch_code.push_str("        _ => {\n");
    dispatch_code.push_str("            panic!(\"Unknown type tag: {}\", data[0]);\n");
    dispatch_code.push_str("        }\n");
    dispatch_code.push_str("    }\n");
    dispatch_code.push_str("    stack.pop_front();\n");
    dispatch_code.push_str("}\n\n");

    // Generate a function to serialize and push an executable to the stack
    dispatch_code.push_str("pub fn push_executable<T: crate::traits::Executable>(stack: &mut verifier::state::BidirectionalStackAccount, executable: T) {\n");
    dispatch_code.push_str("    let mut serialized = Vec::new();\n");
    dispatch_code.push_str("    serialized.push(T::TYPE_TAG);\n");
    dispatch_code.push_str("    serialized.extend_from_slice(executable.as_bytes());\n");
    dispatch_code.push_str("    stack.push_front(&serialized).unwrap();\n");
    dispatch_code.push_str("}\n");

    // Write the generated code to a file
    let mut file = fs::File::create(out_path).unwrap();
    file.write_all(dispatch_code.as_bytes()).unwrap();

    println!(
        "cargo:warning=Auto-generated code for {} Executable types",
        types.len()
    );
}

// Helper function to recursively visit directories and find Rust files
fn visit_dir(dir: &Path, types: &mut HashSet<String>) {
    if dir.is_dir() {
        for entry in fs::read_dir(dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                visit_dir(&path, types);
            } else if let Some(extension) = path.extension() {
                if extension == "rs" {
                    find_executable_types(&path, types);
                }
            }
        }
    }
}

// Parse a Rust file to find types implementing the Executable trait
fn find_executable_types(file_path: &Path, types: &mut HashSet<String>) {
    let content = fs::read_to_string(file_path).unwrap();

    // Skip the traits.rs file since it defines the trait
    if file_path.file_name().unwrap() == "traits.rs" {
        return;
    }

    // Look for module name
    let mod_name = file_path.file_stem().unwrap().to_string_lossy().to_string();

    // Check if the file implements Executable trait
    if content.contains("impl Executable for")
        || content.contains("impl traits::Executable for")
        || content.contains("impl crate::traits::Executable for")
    {
        // Extract struct names
        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("pub struct ") {
                let struct_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or_default()
                    .trim_matches(|c| c == '{' || c == ' ' || c == '\t');

                // Add the fully qualified name
                types.insert(format!("{}::{}", mod_name, struct_name));
            }
        }
    }
}
