use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=src");
    println!("cargo:rerun-if-changed=../animals/src");

    // Find all Rust files in the src directory
    let src_dir = Path::new("src");
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("executable_dispatch.rs");

    let mut types = HashSet::new();

    // Find all files implementing the Executable trait in the current crate
    visit_dir(src_dir, &mut types, "crate");

    // Also check for types in the animals crate
    if let Ok(meta) = fs::metadata("../animals/src") {
        if meta.is_dir() {
            visit_dir(Path::new("../animals/src"), &mut types, "animals");
        }
    }

    // Generate the dispatch code
    let mut dispatch_code = String::new();

    // Add header with imports
    dispatch_code.push_str("// AUTO-GENERATED by build.rs\n");
    dispatch_code.push_str("// Do not edit this file directly\n\n");

    // Generate the execute function
    dispatch_code
        .push_str("pub fn execute(stack: &mut verifier::state::BidirectionalStackAccount) {\n");
    dispatch_code.push_str("    let data = stack.borrow_mut_front();\n");
    dispatch_code.push_str("    match data[0] {\n");

    // Add a case for each type
    for (type_name, crate_name) in &types {
        let struct_name = type_name.split("::").last().unwrap_or(type_name);

        if crate_name == "crate" {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!("        crate::{}::TYPE_TAG => {{\n", type_name));
            dispatch_code.push_str(&format!(
                "            let {} = crate::{}::cast_mut(&mut data[1..]);\n",
                struct_name.to_lowercase(),
                type_name
            ));
        } else {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!(
                "        {}::{}::TYPE_TAG => {{\n",
                crate_name, type_name
            ));
            dispatch_code.push_str(&format!(
                "            let {} = {}::{}::cast_mut(&mut data[1..]);\n",
                struct_name.to_lowercase(),
                crate_name,
                type_name
            ));
        }

        dispatch_code.push_str(&format!(
            "            {}.execute();\n",
            struct_name.to_lowercase()
        ));
        dispatch_code.push_str("        },\n");
    }

    // Add default case
    dispatch_code.push_str("        _ => {\n");
    dispatch_code.push_str("            panic!(\"Unknown type tag: {}\", data[0]);\n");
    dispatch_code.push_str("        }\n");
    dispatch_code.push_str("    }\n");
    dispatch_code.push_str("    stack.pop_front();\n");
    dispatch_code.push_str("}\n");

    // Write the generated code to a file
    let mut file = fs::File::create(out_path).unwrap();
    file.write_all(dispatch_code.as_bytes()).unwrap();

    println!(
        "cargo:warning=Auto-generated code for {} Executable types",
        types.len()
    );
}

// Helper function to recursively visit directories and find Rust files
fn visit_dir(dir: &Path, types: &mut HashSet<(String, String)>, crate_name: &str) {
    if dir.is_dir() {
        for entry in fs::read_dir(dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                visit_dir(&path, types, crate_name);
            } else if let Some(extension) = path.extension() {
                if extension == "rs" {
                    find_executable_types(&path, types, crate_name);
                }
            }
        }
    }
}

// Parse a Rust file to find types implementing the Executable trait
fn find_executable_types(
    file_path: &Path,
    types: &mut HashSet<(String, String)>,
    crate_name: &str,
) {
    let content = fs::read_to_string(file_path).unwrap();

    // Skip the traits.rs file since it defines the trait
    if file_path.file_name().unwrap() == "traits.rs" || file_path.file_name().unwrap() == "lib.rs" {
        return;
    }

    // Look for module name
    let mod_name = file_path.file_stem().unwrap().to_string_lossy().to_string();

    // Check if the file implements Executable trait
    if content.contains("impl Executable for")
        || content.contains("impl traits::Executable for")
        || content.contains("impl crate::traits::Executable for")
        || content.contains("impl dynamic::traits::Executable for")
    {
        // Extract struct names
        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("pub struct ") {
                let struct_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or_default()
                    .trim_matches(|c| c == '{' || c == ' ' || c == '\t');

                // Add the fully qualified name and crate
                types.insert((
                    format!("{}::{}", mod_name, struct_name),
                    crate_name.to_string(),
                ));
            }
        }
    }
}
