use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() {
    println!("cargo:rerun-if-changed=src");

    // Get the current crate name from Cargo.toml
    let current_crate_name = env::var("CARGO_PKG_NAME").unwrap_or_else(|_| "unknown".to_string());

    // Find the workspace root directory
    let workspace_root = find_workspace_root().unwrap_or_else(|| PathBuf::from("."));

    // Get the out directory for generated code
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let out_filename = format!("{}_executable_dispatch.rs", current_crate_name);
    let out_path = Path::new(&out_dir).join(out_filename);

    let mut types = HashSet::new();

    // Find all crates in the workspace by reading the Cargo.toml
    let workspace_members = get_workspace_members(&workspace_root);

    // Search for Executable implementations in each workspace member
    for member_path in workspace_members {
        let src_dir = workspace_root.join(&member_path).join("src");
        if src_dir.exists() {
            let crate_name = member_path
                .file_name()
                .and_then(|name| name.to_str())
                .unwrap_or("unknown");

            // Use the actual crate name for the current crate, otherwise use the directory name
            let effective_crate_name =
                if member_path.to_string_lossy().contains(&current_crate_name) {
                    "crate".to_string()
                } else {
                    crate_name.to_string()
                };

            visit_dir(&src_dir, &mut types, &effective_crate_name);
        }
    }

    // Generate the dispatch code
    let mut dispatch_code = String::new();

    // Add header with imports
    dispatch_code.push_str("// AUTO-GENERATED by build.rs\n");
    dispatch_code.push_str("// Do not edit this file directly\n\n");

    // Generate the execute function
    dispatch_code
        .push_str("pub fn execute(stack: &mut crate::state::BidirectionalStackAccount) {\n");
    dispatch_code.push_str("    // Create a raw pointer to avoid multiple mutable borrow issues\n");
    dispatch_code
        .push_str("    let stack_ptr = stack as *mut crate::state::BidirectionalStackAccount;\n");
    dispatch_code.push_str("    \n");
    dispatch_code.push_str("    // Get the data from the back of the stack using unsafe\n");
    dispatch_code.push_str("    let data = unsafe { (*stack_ptr).borrow_mut_back() };\n");

    // We need to ensure we have enough data (at least 4 bytes for u32)
    dispatch_code.push_str("    if data.len() < 4 {\n");
    dispatch_code.push_str("        panic!(\"Data too short to contain type tag\");\n");
    dispatch_code.push_str("    }\n");

    // Read the 32-bit type tag from the first 4 bytes
    dispatch_code
        .push_str("    let type_tag_bytes: [u8; 4] = [data[0], data[1], data[2], data[3]];\n");
    dispatch_code.push_str("    let type_tag = u32::from_le_bytes(type_tag_bytes);\n");

    // Remove the task from the stack before processing
    dispatch_code.push_str("    // Remove the task from the stack\n");
    dispatch_code.push_str("    unsafe {\n");
    dispatch_code.push_str("        let _task_data = (*stack_ptr).borrow_back().to_vec();\n");
    dispatch_code.push_str("        (*stack_ptr).pop_back();\n");
    dispatch_code.push_str("    }\n");

    dispatch_code.push_str("    match type_tag {\n");

    // Add a case for each type in all crates
    for (type_name, crate_name) in &types {
        let struct_name = type_name.split("::").last().unwrap_or(type_name);

        if crate_name == "crate" {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!("        crate::{}::TYPE_TAG => {{\n", type_name));
            dispatch_code.push_str(&format!(
                "            // Create a new instance for the type\n"
            ));
            dispatch_code.push_str(&format!(
                "            let mut {} = crate::{}::new(\"\");\n",
                struct_name.to_lowercase(),
                type_name
            ));
            dispatch_code.push_str(&format!(
                "            // Execute the task using unsafe to get around borrow checker\n"
            ));
            dispatch_code.push_str(&format!(
                "            unsafe {{\n                {}.execute(&mut *stack_ptr);\n            }}\n",
                struct_name.to_lowercase()
            ));
            dispatch_code.push_str("        },\n");
        } else {
            dispatch_code.push_str(&format!("        // TYPE_TAG from {} crate\n", crate_name));
            dispatch_code.push_str(&format!(
                "        {}::{}::TYPE_TAG => {{\n",
                crate_name, type_name
            ));

            // Special case for types that need more than one parameter
            if struct_name == "Bird" {
                dispatch_code.push_str(&format!(
                    "            // Create a new instance for the type\n"
                ));
                dispatch_code.push_str(&format!(
                    "            let mut {} = {}::{}::new(\"\", false);\n",
                    struct_name.to_lowercase(),
                    crate_name,
                    type_name
                ));
            } else if struct_name == "Frog" {
                dispatch_code.push_str(&format!(
                    "            // Create a new instance for the type\n"
                ));
                dispatch_code.push_str(&format!(
                    "            let mut {} = {}::{}::new(\"\", false);\n",
                    struct_name.to_lowercase(),
                    crate_name,
                    type_name
                ));
            } else {
                dispatch_code.push_str(&format!(
                    "            // Create a new instance for the type\n"
                ));
                dispatch_code.push_str(&format!(
                    "            let mut {} = {}::{}::new(\"\");\n",
                    struct_name.to_lowercase(),
                    crate_name,
                    type_name
                ));
            }

            dispatch_code.push_str(&format!(
                "            // Execute the task using unsafe to get around borrow checker\n"
            ));
            dispatch_code.push_str(&format!(
                "            unsafe {{\n                {}.execute(&mut *stack_ptr);\n            }}\n",
                struct_name.to_lowercase()
            ));
            dispatch_code.push_str("        },\n");
        }
    }

    // Add default case
    dispatch_code.push_str("        _ => {\n");
    dispatch_code.push_str("            panic!(\"Unknown type tag: {}\", type_tag);\n");
    dispatch_code.push_str("        }\n");
    dispatch_code.push_str("    }\n");
    dispatch_code.push_str("}\n");

    // Write the generated code to a file
    let mut file = fs::File::create(out_path).unwrap();
    file.write_all(dispatch_code.as_bytes()).unwrap();

    println!(
        "cargo:warning=Auto-generated code for {} Executable types across workspace",
        types.len()
    );
}

// Find the workspace root directory by looking for Cargo.toml with [workspace]
fn find_workspace_root() -> Option<PathBuf> {
    let mut current_dir = env::current_dir().ok()?;

    loop {
        let cargo_toml_path = current_dir.join("Cargo.toml");

        if cargo_toml_path.exists() {
            if let Ok(content) = fs::read_to_string(&cargo_toml_path) {
                if content.contains("[workspace]") {
                    return Some(current_dir);
                }
            }
        }

        if !current_dir.pop() {
            break;
        }
    }

    None
}

// Get workspace members from Cargo.toml
fn get_workspace_members(workspace_root: &Path) -> Vec<PathBuf> {
    let cargo_toml_path = workspace_root.join("Cargo.toml");
    let mut members = Vec::new();

    if let Ok(content) = fs::read_to_string(&cargo_toml_path) {
        // Parse the members section
        if let Some(members_section) = content.split("[workspace]").nth(1) {
            if let Some(members_list) = members_section.split("members").nth(1) {
                if let Some(list) = members_list.split(']').next() {
                    if let Some(list) = list.split('[').nth(1) {
                        for member in list.split(',') {
                            let member = member.trim().trim_matches('"');

                            // Handle glob patterns like "programs/*"
                            if member.contains('*') {
                                let base_path = member.split('*').next().unwrap_or("");
                                if let Ok(entries) = fs::read_dir(workspace_root.join(base_path)) {
                                    for entry in entries.flatten() {
                                        let path = entry.path();
                                        if path.is_dir() && path.join("Cargo.toml").exists() {
                                            let rel_path =
                                                pathdiff::diff_paths(&path, workspace_root)
                                                    .unwrap_or_else(|| path.clone());
                                            members.push(rel_path);
                                        }
                                    }
                                }
                            } else if !member.is_empty() {
                                members.push(PathBuf::from(member));
                            }
                        }
                    }
                }
            }
        }
    }

    // Always include the current directory
    members.push(PathBuf::from("."));

    members
}

// Helper function to recursively visit directories and find Rust files
fn visit_dir(dir: &Path, types: &mut HashSet<(String, String)>, crate_name: &str) {
    if dir.is_dir() {
        if let Ok(entries) = fs::read_dir(dir) {
            for entry in entries {
                if let Ok(entry) = entry {
                    let path = entry.path();
                    if path.is_dir() {
                        visit_dir(&path, types, crate_name);
                    } else if let Some(extension) = path.extension() {
                        if extension == "rs" {
                            find_executable_types(&path, types, crate_name);
                        }
                    }
                }
            }
        }
    }
}

// Parse a Rust file to find types implementing the Executable trait
fn find_executable_types(
    file_path: &Path,
    types: &mut HashSet<(String, String)>,
    crate_name: &str,
) {
    let content = fs::read_to_string(file_path).unwrap_or_default();
    let file_name = file_path.file_name().unwrap_or_default().to_string_lossy();

    // Skip the traits.rs file since it defines the trait, but do check lib.rs for implementations
    if file_name == "traits.rs" {
        return;
    }

    // Look for module name - use empty string for lib.rs to create root-level paths
    let mod_name = if file_name == "lib.rs" {
        "".to_string()
    } else {
        file_path
            .file_stem()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string()
    };

    // Check if the file implements Executable trait
    if content.contains("impl Executable for")
        || content.contains("impl traits::Executable for")
        || content.contains("impl crate::traits::Executable for")
        || content.contains("impl dynamic::traits::Executable for")
        || content.contains("impl utils::Executable for")
    {
        // Extract struct names
        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("pub struct ") {
                let struct_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or_default()
                    .trim_matches(|c| c == '{' || c == ' ' || c == '\t');

                // Create the fully qualified path
                let full_path = if mod_name.is_empty() {
                    struct_name.to_string()
                } else {
                    format!("{}::{}", mod_name, struct_name)
                };

                // Add the fully qualified name and crate
                types.insert((full_path, crate_name.to_string()));
            }
        }
    }
}
